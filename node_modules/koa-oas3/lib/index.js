"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const config_1 = require("./config");
const oas3_chow_chow_1 = require("oas3-chow-chow");
exports.ChowError = oas3_chow_chow_1.ChowError;
exports.RequestValidationError = oas3_chow_chow_1.RequestValidationError;
exports.ResponseValidationError = oas3_chow_chow_1.ResponseValidationError;
const openapi_ui_1 = require("./openapi-ui");
const jsonfile = require("jsonfile");
const yaml = require("js-yaml");
const fs = require("fs");
const oasValidator = require("oas-validator");
const compose = require("koa-compose");
const qs = require("qs");
function oas(cfg) {
    const config = config_1.validateConfig(cfg);
    const { compiled, doc } = compileOas(config);
    const validatorMW = async (ctx, next) => {
        try {
            const validRequest = compiled.validateRequestByPath(ctx.path, ctx.request.method, {
                header: ctx.request.header,
                query: qs.parse(ctx.request.querystring, config.qsParseOptions),
                path: ctx.params,
                cookie: ctx.cookies,
                body: ctx.request.body,
            });
            // Store coerced values
            ctx.oas = {
                request: {
                    query: validRequest.query,
                    params: validRequest.path && validRequest.path.params,
                    header: validRequest.header
                }
            };
        }
        catch (err) {
            config.errorHandler(err, ctx);
        }
        await next();
        if (config.validateResponse) {
            try {
                compiled.validateResponseByPath(ctx.path, ctx.method, {
                    status: ctx.status,
                    header: ctx.response.header,
                    body: ctx.body
                });
            }
            catch (err) {
                config.errorHandler(err, ctx);
            }
        }
    };
    const composedMW = async (ctx, next) => {
        if (config.enableUi && ctx.path === config.endpoint) {
            ctx.body = doc;
            return;
        }
        if (config.enableUi && ctx.path === config.uiEndpoint) {
            ctx.body = openapi_ui_1.openapiUI({
                title: doc.info ? doc.info.title : 'openapi UI',
                url: config.endpoint,
                swaggerUiBundleBasePath: config.swaggerUiBundleBasePath
            });
            return;
        }
        if (!config.validatePaths.some(path => ctx.path.startsWith(path))) {
            // Skip validation if no path matches
            return next();
        }
        const middlewares = [];
        const requestContentTypes = compiled.getDefinedRequestBodyContentType(ctx.path, ctx.request.method);
        const matchedContentType = ctx.request.is(requestContentTypes);
        if (requestContentTypes.length && config.requestBodyHandler && matchedContentType && typeof matchedContentType === 'string') {
            // We need to find the most specific matched handler
            const parts = matchedContentType.split('/');
            if (config.requestBodyHandler[matchedContentType]) {
                middlewares.push(config.requestBodyHandler[matchedContentType]); // For a specific match like `application/json`
            }
            else if (config.requestBodyHandler[`${parts[0]}/*`]) {
                middlewares.push(config.requestBodyHandler[`${parts[0]}/*`]); // For a match like `application/*`
            }
            else if (config.requestBodyHandler[`*/${parts[1]}`]) {
                middlewares.push(config.requestBodyHandler[`*/${parts[1]}`]); // For a match like `*/json`
            }
            else if (config.requestBodyHandler['*/*']) {
                middlewares.push(config.requestBodyHandler['*/*']); // For a global type match defined as `*/*`
            }
        }
        middlewares.push(validatorMW);
        await compose(middlewares).call(this, ctx, next);
    };
    return composedMW;
}
exports.oas = oas;
function loadFromFile(file) {
    if (!file) {
        throw new Error("Missing file path");
    }
    switch (true) {
        case file.endsWith('.json'): {
            return jsonfile.readFileSync(file);
        }
        case file.endsWith('.yml') || file.endsWith('.yaml'): {
            return yaml.safeLoad(fs.readFileSync(file, 'utf8'));
        }
        default:
            throw new Error('Unsupported file format');
    }
}
function compileOas(config) {
    let openApiObject = config.spec || loadFromFile(config.file);
    if (!oasValidator.validateSync(openApiObject, {})) {
        throw new Error('Invalid Openapi document');
    }
    return {
        compiled: new oas3_chow_chow_1.default(openApiObject, config.validationOptions),
        doc: openApiObject,
    };
}
//# sourceMappingURL=index.js.map